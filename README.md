# CS-320-Project-1

Ensuring the functionality and security of code, programs, or software can be a complex endeavor. While I have gained some experience with code testing in this course, I've come to realize that ensuring everything works properly can be quite demanding. Prior to taking this class, I underestimated the level of involvement required for these tasks. However, I have developed a set of strategies to ensure my code is both secure and functional.

Firstly, I prioritize adhering closely to the given requirements. By meticulously following the specifications, I can ensure that the code meets the intended functionality and incorporates necessary security measures. This involves carefully analyzing and comprehending the requirements to identify potential challenges and limitations. I place significant emphasis on writing extensive tests that provide a high coverage percentage during the testing phase. In the program I developed for this class, I engaged in thorough testing, repeatedly iterating and refining until I achieved at least 90% coverage. This approach allows me to identify potential issues and verify that the code functions as intended.

To interpret user needs, I adopt a systematic approach. I begin by thoroughly reading and comprehending their requirements. Next, I break down these needs into specific aspects that are feasible and compatible with the program. For instance, when faced with constraints such as maximum length and empty submissions, I address them by incorporating conditional statements that account for both failure options. This basic approach translates user needs into the program logic by employing conditionals for successful execution. In cases where requirements are more ambiguous, I conduct further analysis to gain a deeper understanding. For example, in another class, I had to develop a program that allowed the user to add time to two separate clocks with the push of a button. This requirement necessitated extensive breakdown and analysis to design an appropriate solution beyond a simple error-handling mechanism.

As for software design, my current approach involves examining requirements documents or interview transcripts (if available) to create a checklist of requirements. If applicable, I break down these requirements into a list of objects and methods necessary to accomplish the desired functionalities. Armed with these lists, I begin writing the code to fulfill the requirements. Once the code is operational, I conduct a review to optimize its efficiency wherever possible. While this approach has proven effective during my studies, I acknowledge the need for further refinement. I aim to develop a more expansive and insightful approach to software design in the future.
